# coding: utf-8

"""
    Translator Knowledge Beacon Aggregator API

    This is the Translator Knowledge Beacon Aggregator web service application programming interface (API) that provides integrated access to a pool of knowledge sources publishing concepts and relations through the Translator Knowledge Beacon API. This API is similar to that of the latter mentioned API with the addition of some extra informative endpoints plus session identifier and beacon indices. These latter identifiers are locally assigned numeric indices provided to track the use of specific registered beacons within the aggregator API itself. 

    OpenAPI spec version: 1.1.1
    Contact: richard@starinformatics.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class MetadataApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def get_beacons(self, **kwargs):
        """
        Get a list of all of the knowledge beacons that the aggregator can query 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_beacons(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[ClientKnowledgeBeacon]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_beacons_with_http_info(**kwargs)
        else:
            (data) = self.get_beacons_with_http_info(**kwargs)
            return data

    def get_beacons_with_http_info(self, **kwargs):
        """
        Get a list of all of the knowledge beacons that the aggregator can query 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_beacons_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[ClientKnowledgeBeacon]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_beacons" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        resource_path = '/beacons'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[ClientKnowledgeBeacon]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_concept_categories(self, **kwargs):
        """
        Get a list of semantic categories and number of instances in each  available knowledge beacon, including associated beacon-specific metadata 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_concept_categories(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[int] beacons: set of aggregator indices of beacons to constrain categories returned 
        :return: list[ClientConceptCategory]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_concept_categories_with_http_info(**kwargs)
        else:
            (data) = self.get_concept_categories_with_http_info(**kwargs)
            return data

    def get_concept_categories_with_http_info(self, **kwargs):
        """
        Get a list of semantic categories and number of instances in each  available knowledge beacon, including associated beacon-specific metadata 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_concept_categories_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[int] beacons: set of aggregator indices of beacons to constrain categories returned 
        :return: list[ClientConceptCategory]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['beacons']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_concept_categories" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/categories'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'beacons' in params:
            query_params['beacons'] = params['beacons']
            collection_formats['beacons'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[ClientConceptCategory]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_errors(self, query_id, **kwargs):
        """
        Get a log of the system errors associated with a specified query 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_errors(query_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str query_id: query identifier returned from a POSTed query  (required)
        :return: list[ClientLogEntry]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_errors_with_http_info(query_id, **kwargs)
        else:
            (data) = self.get_errors_with_http_info(query_id, **kwargs)
            return data

    def get_errors_with_http_info(self, query_id, **kwargs):
        """
        Get a log of the system errors associated with a specified query 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_errors_with_http_info(query_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str query_id: query identifier returned from a POSTed query  (required)
        :return: list[ClientLogEntry]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_errors" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query_id' is set
        if ('query_id' not in params) or (params['query_id'] is None):
            raise ValueError("Missing the required parameter `query_id` when calling `get_errors`")


        collection_formats = {}

        resource_path = '/errorlog'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'query_id' in params:
            query_params['queryId'] = params['query_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[ClientLogEntry]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_knowledge_map(self, **kwargs):
        """
        Get a high level knowledge map of the all the beacons specified by triplets of subject concept category, relationship predicate and concept object category 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_knowledge_map(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[int] beacons: set of aggregator indices of beacons constraining knowledge maps returned  
        :return: list[ClientKnowledgeMap]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_knowledge_map_with_http_info(**kwargs)
        else:
            (data) = self.get_knowledge_map_with_http_info(**kwargs)
            return data

    def get_knowledge_map_with_http_info(self, **kwargs):
        """
        Get a high level knowledge map of the all the beacons specified by triplets of subject concept category, relationship predicate and concept object category 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_knowledge_map_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[int] beacons: set of aggregator indices of beacons constraining knowledge maps returned  
        :return: list[ClientKnowledgeMap]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['beacons']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_knowledge_map" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/kmap'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'beacons' in params:
            query_params['beacons'] = params['beacons']
            collection_formats['beacons'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[ClientKnowledgeMap]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_predicates(self, **kwargs):
        """
        Get a list of predicates used in statements issued by the knowledge source 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_predicates(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[int] beacons: set of aggregator indices of beacons to constrain predicates returned 
        :return: list[ClientPredicate]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_predicates_with_http_info(**kwargs)
        else:
            (data) = self.get_predicates_with_http_info(**kwargs)
            return data

    def get_predicates_with_http_info(self, **kwargs):
        """
        Get a list of predicates used in statements issued by the knowledge source 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_predicates_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[int] beacons: set of aggregator indices of beacons to constrain predicates returned 
        :return: list[ClientPredicate]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['beacons']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_predicates" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/predicates'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'beacons' in params:
            query_params['beacons'] = params['beacons']
            collection_formats['beacons'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[ClientPredicate]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
